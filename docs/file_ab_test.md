Procedural attribute macro for generating A/B tests for every file at a given path.

This macro works by giving a suffix for an input file, a suffix for a gold file and a path to look
in. It will recursively search the path for any file ending with the suffix, and, for each of
those, looks for a file with the same basename but the gold file suffix. The first file, then,
serves as the input to your test; and the second file as the "gold" or correct answer.

To illustrate, consider the following filesystem:
```plain
foo/
  src/
    lib.rs
  tests/
    test.rs
    cases/
      hello_world.txt
      hello_world.gold.txt
```
If we specify `.txt` as the input suffix, `.gold.txt` as the output suffix and the `tests`-folder
as the path, then it would find a `hello_world` testcase with the correct answer in
`hello_world.gold.txt`.

For each such testcase, a function is generated that will load the two files and calls your
function with the paths and contents. See below for an example.

# Usage
Use this attribute macro by attaching it to a function, like so:
```ignore
#[file_ab_test(<INPUT>, <GOLD>, <PATH>)]
fn test_foo(input_path: PathBuf, input: Vec<u8>, gold_path: PathBuf, gold: Vec<u8>) {
    // Test code as normal...
}
```
See below to find which argument to give to the attribute macro itself.

Your function is called for every found testcase. It is given (in-order) the path of the input
file; the contents of the input file (the raw bytes); the path of the gold file; and the contents
of the gold file (the raw bytes).

You can use these contents to run the code you want to test and compare it to the gold value. As
per usual, if you are somehow not happy with the test, [`panic!()`](std::panic!()) to let the test
harness know the test failed.

## Syntax
This macro accepts three input arguments, which you can give in-order as positional values or
out-of-order using `key = value`-syntax:
- `input`: The suffix of the input files. Note that suffixes are matched _as a whole_ on the _first
  dot in the filename and then everything after that_. So for a filename `hello_world.txt`, `.txt`
  is the suffix to be matched; for a filename `foo.bar.baz.quz`, the suffix is `.bar.baz.quz`.
- `gold`: The suffix of the gold files. These are matched differently: when an input file is found,
  its name _without_ the suffix is appended with the gold suffix and that file is looked for. For
  example, if a file `foo.bar.baz` is found and the gold suffix is `.gold`, then the gold file is
  assumed to be `foo.gold`.
- `path`: The path to look for test files in. May be either a file or a directory, where the latter
  is recursively searched. Note that a given standalone file still needs to match the input suffix!
  I.e., nothing is generated if your suffix is `.txt` but the path is `hello_world.doc`.

The following are all valid examples for giving the input suffix `.txt`, gold suffix `.gold.txt`
and path `foo`:
```ignore
#[file_ab_test(".txt", ".gold.txt", "foo")]
#[file_ab_test(".txt", ".gold.txt", path = "foo")]
#[file_ab_test(input = ".txt", gold = ".gold.txt", path = "foo")]
#[file_ab_test(input = ".txt", path = "foo", gold = ".gold.txt")]
```

## Test name generation
Tests are generated by taking the "suffixless filename" (see above for what this means) and
replacing any non-alphabetic (lower- or uppercase), non-numeric character into an underscore `_`.
Then it is prefixed by the name of your function and an underscore.

For example, using this macro on a function `test_lowercase` and an input file `hello_world.txt`
produces a unit test called `test_lowercase_hello_world`.

It can be that names conflict, in two cases:
- There are two files with the same name in two different directories. In that case, the differing
  paths are included; e.g., if we have `foo/hello-world.txt` and `hello-world.txt`, the names are
  `test_lowercase_foo_hello_world` and `test_lowercase_hello_world`, respectively.
- There are two files in the same folder that collide because the identifiers are simplified. In
  that case, the functions are simply appended with a unique number. For example, a folder with
  `hello-world.txt` and `hello_world.txt` generates unit tests with names
  `test_lowercase_hello_world1` and `test_lowercase_hello_world2`, respectively (ordered
  alphabetically by Rust's judgement).

# Examples
An example of using this macro to try [`str::to_lowercase()`] for various input files:
```ignore
use std::path::PathBuf;

use filetest::file_ab_test;

#[file_ab_test(".txt", ".gold.txt", "files")]
fn test_to_lowercase(input_path: PathBuf, input: Vec<u8>, _: PathBuf, gold: Vec<u8>) {
    // Read the input- and gold as strings
    let input = std::str::from_utf8(&input).unwrap();
    let gold = std::str::from_utf8(&gold).unwrap();
  
    // Run our to-be-tested code
    let pred = input.to_lowercase();

    // Check if they match!
    if pred != gold {
        panic!("Test failed for input file {input_path:?}");
    }
}
```
